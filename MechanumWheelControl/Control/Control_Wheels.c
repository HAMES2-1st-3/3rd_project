/**********************************************************************************************************************
 * \file Control_Wheels.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include <Control_Wheels.h>

#include <Driver_Potentiometer.h>
#include <Driver_USB.h>

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define P_GAIN 1
#define I_GAIN 1

#define MAX_RPM 5000

#define FLnRR_VEC_X (-1.0)
#define FLnRR_VEC_Y (1.0)
#define FRnRL_VEC_X (1.0)
#define FRnRL_VEC_Y (1.0)

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
static float32 LPF(float32 Y_fill_d,float32 u,float32 cf,float32 T);


/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/


WheelTicks get_wheel_ticks(){
    WheelTicks ticks;

    ticks.fl = get_wheelFL_tick();
    ticks.fr = get_wheelFR_tick();
    ticks.rl = get_wheelRL_tick();
    ticks.rr = get_wheelRR_tick();

    return ticks;
}

WheelRPMs calc_wheel_rpms_measured(WheelTicks wheel_ticks, float32 Ts){
    static sint32 ticks_cur[4] = {0,};
    static sint32 ticks_prev[4] = {0,};

    static float32 w_cur[4] = {0,};
    static float32 w_prev[4] = {0,};

    WheelRPMs result;

    float32 cutoff = 10;

    ticks_cur[0] = wheel_ticks.fl;
    ticks_cur[1] = wheel_ticks.fr;
    ticks_cur[2] = wheel_ticks.rl;
    ticks_cur[3] = wheel_ticks.rr;

    for(int i = 0 ; i < 4; i++) {
        w_cur[i] = (ticks_cur[i]-ticks_prev[i])/Ts;
        w_cur[i] = LPF(w_prev[i],w_cur[i],cutoff,Ts);

        w_prev[i] = w_cur[i];
        ticks_prev[i] = ticks_cur[i];
    }

    result.fl = (float32)w_cur[0] * (60/22.0);
    result.fr = (float32)w_cur[1] * (60/22.0);
    result.rl = (float32)w_cur[2] * (60/22.0);
    result.rr = (float32)w_cur[3] * (60/22.0);

    return result;
}

static float32 LPF(float32 Y_fill_d,float32 u,float32 cf,float32 T){ // cf=cutoff
    return (1-T*cf)*Y_fill_d+T*cf*u;
}


WheelRPMs calc_wheel_rpms_error(WheelRPMs wheel_rpms_ref, WheelRPMs wheel_rpms_measured){
    WheelRPMs errors;

    errors.fl = wheel_rpms_ref.fl - wheel_rpms_measured.fl;
    errors.fr = wheel_rpms_ref.fr - wheel_rpms_measured.fr;
    errors.rl = wheel_rpms_ref.rl - wheel_rpms_measured.rl;
    errors.rr = wheel_rpms_ref.rr - wheel_rpms_measured.rr;

    return errors;
}

WheelDutycycles pid_controller(WheelRPMs wheel_rpms_error) {
    WheelDutycycles result = {0,};
    ;
    return result;
}
//-100 ~ 100;
WheelDutycycles open_loop_controller(WheelRPMs wheel_rpms) {
    WheelDutycycles result;

    result.fl = wheel_rpms.fl * 100 / MAX_RPM;
    result.fr = wheel_rpms.fr * 100 / MAX_RPM;
    result.rl = wheel_rpms.rl * 100 / MAX_RPM;
    result.rr = wheel_rpms.rr * 100 / MAX_RPM;

    return result;
}

void set_wheels_dutycycle(WheelDutycycles wheel_dutycycles) {
    set_wheelFL_dutycycle(wheel_dutycycles.fl);
    set_wheelFR_dutycycle(wheel_dutycycles.fr);
    set_wheelRL_dutycycle(wheel_dutycycles.rl);
    set_wheelRR_dutycycle(wheel_dutycycles.rr);
}



//-MAX_RPM ~ MAX_RPM;
WheelRPMs calc_wheel_rpms_ref(uint32 rpm_max, JoystickValues joystick_values) {
    WheelRPMs result_rpm;

    float32 mov_x = (float32)(joystick_values.move.x - JOYSTICK_MAX_VALUE/2);
    float32 mov_y = (float32)((JOYSTICK_MAX_VALUE - joystick_values.move.y) - JOYSTICK_MAX_VALUE/2);

#define JOYSTICK_ROTATE_COMPENSATE 1
#if JOYSTICK_ROTATE_COMPENSATE == 1
    float32 rot_x = (float32)(joystick_values.rotate.x - JOYSTICK_MAX_VALUE/2);
    float32 rot_y = (float32)((JOYSTICK_MAX_VALUE - joystick_values.rotate.y) - JOYSTICK_MAX_VALUE/2);
#else
    sint32 rot_x = (float32)((JOYSTICK_MAX_VALUE - joystick_values.rotate.x) - JOYSTICK_MAX_VALUE/2);
    sint32 rot_y = (float32)(joystick_values.rotate.y - JOYSTICK_MAX_VALUE/2);
#endif

    mov_x = mov_x / (JOYSTICK_MAX_VALUE/2);
    mov_y = mov_y / (JOYSTICK_MAX_VALUE/2);
    rot_x = rot_x / (JOYSTICK_MAX_VALUE/2);
    rot_y = rot_y / (JOYSTICK_MAX_VALUE/2);

    send_usb_printf("A: %f B: %f C: %f D: %f\n",
            mov_x,
            mov_y,
            rot_x,
            rot_y);


    float32 gain = 0;
    if(mov_x >= 0 && mov_y >= 0) {
        if(mov_x >= mov_y) {
            gain = (2/(mov_y+1))*(mov_x);
        } else {
            gain = (2/(mov_x+1))*(mov_y);
        }
    } else if(mov_x < 0 && mov_y >= 0) {
        if(-mov_x <= mov_y) {
            gain = (2/(-mov_x+1))*(mov_y);
        } else {
            gain = (2/(mov_y+1))*(-mov_x);
        }
    } else if(mov_x < 0 && mov_y < 0) {
        if(-mov_x >= -mov_y) {
            gain = (2/(-mov_y+1))*(-mov_x);
        } else {
            gain = (2/(-mov_x+1))*(-mov_y);
        }
    } else if(mov_x >= 0 && mov_y < 0) {
        if(mov_x <= -mov_y) {
            gain = (2/(mov_x+1))*(-mov_y);
        } else {
            gain = (2/(-mov_y+1))*(mov_x);
        }
    }

    mov_x = gain * mov_x;
    mov_y = gain * mov_y;

    float32 flnrr_rpm = (float32)(((mov_x * FLnRR_VEC_X + mov_y * FLnRR_VEC_Y)/2) * rpm_max);
    float32 frnrl_rpm = (float32)(((mov_x * FRnRL_VEC_X + mov_y * FRnRL_VEC_Y)/2) * rpm_max);

    result_rpm.fl = flnrr_rpm;
    result_rpm.fr = frnrl_rpm;
    result_rpm.rl = frnrl_rpm;
    result_rpm.rr = flnrr_rpm;

    return result_rpm;
}






uint32 get_max_rpm(sint32 dist, uint32 rpm_max) {
    uint32 result_rpm_max;

    if(dist < 0) {
        result_rpm_max = rpm_max ;
    } else if (dist < 105) {
        result_rpm_max = 0;
    } else if (dist < 505) {
        result_rpm_max = (uint32)(rpm_max / 2);
    } else {
        result_rpm_max = rpm_max;
    }

    return (result_rpm_max * MAX_RPM) / POTENTIOMETER_MAX_VALUE;
}



